import time, _thread, socket
import network
from machine import SPI, Pin, I2C
from xglcd_font import XglcdFont
import ili9488
import icons          # Your icons library (includes functions like color565_BGR, draw_temp_icon, etc.)
from sen5x.sen5x import SEN5x

# ---------- Global Variables ----------
sensor_data = {
    'ppm1_0': 0,
    'ppm2_5': 0,
    'ppm4_0': 0,
    'ppm10_0': 0,
    'humidity': 0,
    'temperature': 0,
    'voc': 0,
    'nox': 0,
}
ip = None  # Will be set after connecting to WiFi

# ---------- WiFi Connection ----------
SSID = 'zombiesRUN'
PASSWORD = 'olaflovesmen'

def wifi_connect():
    global ip
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(SSID, PASSWORD)
    print("Connecting to WiFi...")
    while not wlan.isconnected():
        time.sleep(1)
    ip = wlan.ifconfig()[0]
    print("Connected, IP address:", ip)
    return ip

# ---------- Sensor Loop ----------
def sensor_loop():
    global sensor_data
    # I2C settings for your sensor
    i2c = I2C(0, scl=Pin(6, pull=Pin.PULL_UP), sda=Pin(5, pull=Pin.PULL_UP), freq=50000)
    with SEN5x(i2c) as sen:
        while True:
            ppm1_0, ppm2_5, ppm4_0, ppm10_0, rh, t, voc, nox = sen.measured_values
            sensor_data = {
                'ppm1_0': ppm1_0,
                'ppm2_5': ppm2_5,
                'ppm4_0': ppm4_0,
                'ppm10_0': ppm10_0,
                'humidity': rh,
                'temperature': t,
                'voc': voc,
                'nox': nox,
            }
            print("Sensor data updated:", sensor_data)
            time.sleep(5)

# ---------- HTTP Server (for Prometheus scraping) ----------
def http_server():
    addr = socket.getaddrinfo('0.0.0.0', 80)[0][-1]
    s = socket.socket()
    s.bind(addr)
    s.listen(1)
    print("HTTP server listening on", addr)
    while True:
        cl, addr = s.accept()
        print("Client connected from", addr)
        cl_file = cl.makefile('rwb', 0)
        # Read and ignore the HTTP request headers
        while True:
            line = cl_file.readline()
            if not line or line == b'\r\n':
                break

        # Format sensor data in Prometheus text format:
        response = ""
        response += "# HELP sen5x_ppm1_0 Particulate Matter 1.0 measurement\n"
        response += "# TYPE sen5x_ppm1_0 gauge\n"
        response += "sen5x_ppm1_0 {}\n".format(sensor_data['ppm1_0'])
        response += "# HELP sen5x_ppm2_5 Particulate Matter 2.5 measurement\n"
        response += "# TYPE sen5x_ppm2_5 gauge\n"
        response += "sen5x_ppm2_5 {}\n".format(sensor_data['ppm2_5'])
        response += "# HELP sen5x_ppm4_0 Particulate Matter 4.0 measurement\n"
        response += "# TYPE sen5x_ppm4_0 gauge\n"
        response += "sen5x_ppm4_0 {}\n".format(sensor_data['ppm4_0'])
        response += "# HELP sen5x_ppm10_0 Particulate Matter 10.0 measurement\n"
        response += "# TYPE sen5x_ppm10_0 gauge\n"
        response += "sen5x_ppm10_0 {}\n".format(sensor_data['ppm10_0'])
        response += "# HELP sen5x_humidity Humidity measurement\n"
        response += "# TYPE sen5x_humidity gauge\n"
        response += "sen5x_humidity {}\n".format(sensor_data['humidity'])
        response += "# HELP sen5x_temperature Temperature measurement\n"
        response += "# TYPE sen5x_temperature gauge\n"
        response += "sen5x_temperature {}\n".format(sensor_data['temperature'])
        response += "# HELP sen5x_voc VOC measurement\n"
        response += "# TYPE sen5x_voc gauge\n"
        response += "sen5x_voc {}\n".format(sensor_data['voc'])
        response += "# HELP sen5x_nox NOx measurement\n"
        response += "# TYPE sen5x_nox gauge\n"
        response += "sen5x_nox {}\n".format(sensor_data['nox'])

        http_response = "HTTP/1.0 200 OK\r\nContent-Type: text/plain\r\n\r\n" + response
        cl.send(http_response)
        cl.close()

# ---------- Dashboard Setup ----------
# Display Initialization
spi = SPI(1, baudrate=80000000, sck=Pin(2), mosi=Pin(7))
disp_width = 320
disp_height = 480
display = ili9488.Display(spi, dc=Pin(10), cs=Pin(8), rst=Pin(4),
                          width=disp_width, height=disp_height)

def clear_text_area(x, y, width, height, bg_color):
    for yy in range(y, y + height):
        for xx in range(x, x + width):
            display.draw_pixel(xx, yy, bg_color)

# Fonts
arcadepix = XglcdFont('fonts/ArcadePix9x11.c', 9, 11)

# Draw Header (Left-justified)
# header_color = icons.color565_BGR(255, 255, 255)
# display.draw_text(10, 5, "SEN55 Sensor Dashboard", arcadepix, header_color)

# Layout: Vertical orientation, 5 rows (one per icon)
icon_size = 80     # Size for each icon
left_margin = 10   # Left margin for icons
row_spacing = 10   # Vertical spacing between rows
header_bottom = 10 # Vertical space reserved for header
num_rows = 5
color = icons.color565_BGR(0, 0, 255)

def update_dashboard():
    """Update the dashboard text labels with current sensor data.
       Assumes the following globals are defined:
         left_margin, icon_size, row_spacing, header_bottom, arcadepix, display, sensor_data
    """
    label_color = icons.color565_BGR(200, 200, 200)
    gap = 5
    text_x = left_margin + icon_size + gap
    current_y = header_bottom

    # Define rows: each tuple is (label, value) except for Particles which gets special handling.
    rows = [
        ("Temperature", sensor_data['temperature']),
        ("Humidity", sensor_data['humidity']),
        ("Particles", None),
        ("VOCs", sensor_data['voc']),
        ("NOx", sensor_data['nox'])
    ]

    for label, value in rows:
        text_y = current_y + (icon_size - 9) // 2  # approximate vertical centering for a one-line label
        if label == "Particles":
            # Draw the label on the first line:
            display.draw_text(text_x, text_y, label + ":", arcadepix, label_color)
            # Prepare the particulate values on a second line.
            ppm_line = (f"1.0: {sensor_data['ppm1_0']}    "
                        f"2.5: {sensor_data['ppm2_5']}    "
                        f"4.0: {sensor_data['ppm4_0']}    "
                        f"10.0: {sensor_data['ppm10_0']}")
            # Draw the second line a few pixels below.
            display.draw_text(text_x, text_y + 10, ppm_line, arcadepix, label_color)
        elif label == "VOCs":
            # Determine color based on voc value
            voc_value = value
            if voc_value < 150:
                voc_color = icons.color565_BGR(0, 255, 0)  # green
            elif voc_value < 250:
                voc_color = icons.color565_BGR(255, 255, 0)  # yellow
            elif voc_value < 400:
                voc_color = icons.color565_BGR(255, 165, 0)  # orange
            else:
                voc_color = icons.color565_BGR(255, 0, 0)  # red
            full_text = f"{label}: {voc_value}"
            clear_text_area(text_x, text_y, 100, 15, 0x0000)  # assuming 0x0000 is your background (black)
            display.draw_text(text_x, text_y, full_text, arcadepix, voc_color)
        else:
            full_text = f"{label}: {value}"
            display.draw_text(text_x, text_y, full_text, arcadepix, label_color)
        current_y += icon_size + row_spacing


def draw_static_dashboard():
    """Draw the static parts of the dashboard (icons, header, etc.)."""
    # Draw each icon (left-justified) in its row.
    icons_and_functions = [
        icons.draw_temp_icon,
        icons.draw_humidity_icon,
        icons.draw_particles_icon,
        icons.draw_vocs_icon,
        icons.draw_nox_icon
    ]
    icon_color = icons.color565_BGR(255, 255, 255)
    current_y = header_bottom
    for draw_func in icons_and_functions:
        draw_func(display, left_margin, current_y, icon_size, icon_color)
        current_y += icon_size + row_spacing

def dashboard_loop():
    # Draw the static icons once.
    draw_static_dashboard()
    # Update the dynamic labels periodically.
    while True:
        update_dashboard()
        # Optionally, update the IP in a footer area:
        display.draw_text(10, disp_height - 15, f"IP: {ip}", arcadepix, color)
        time.sleep(10)

# ---------- Main Function ----------
def main():
    # Connect to WiFi (this sets the global ip variable)
    wifi_connect()
    # Start sensor loop in a background thread
    _thread.start_new_thread(sensor_loop, ())
    # Start HTTP server in a background thread
    _thread.start_new_thread(http_server, ())
    # Run dashboard update loop in the main thread
    dashboard_loop()

if __name__ == '__main__':
    main()
